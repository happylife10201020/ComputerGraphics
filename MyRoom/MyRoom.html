<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Material, Light and Shadow</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>

    <script type="importmap">
        {
            "imports" : {
                "three" : "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/" : "https://unpkg.com/three@0.150.1/examples/jsm/",
                "three/examples/jsm/controls/DragControls.js": "https://unpkg.com/three@0.150.1/examples/jsm/controls/DragControls.js",
                "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
</head>

<body>
<div id="WebGL-output"></div>
<script type="module">
    import * as THREE from "three" ;
    import {OrbitControls} from "three/addons/controls/OrbitControls.js" ;
    import {DragControls} from 'three/examples/jsm/controls/DragControls.js';
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";


    // ==========================================================
    // 기본 설정
    // ==========================================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xd7d7df);  // 약간 밝은 회색

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(110, 90, 110);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.getElementById("WebGL-output").appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();

    const loader = new GLTFLoader();


    // 바닥 텍스처
    const floorTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4, 4);

    // ====================================================================
    // 헬퍼 함수: 박스 메쉬 생성
    // ====================================================================
    function createBoxMesh(width, height, depth, color, name = '') {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.05,
            roughness: 0.85
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = name;
        return mesh;
    }

    // ====================================================================
    // 1. 방 기본 구조 
    // ====================================================================
    const axes = new THREE.AxesHelper(200);
    scene.add(axes);

    const plane = createBoxMesh(100, 1, 100, 0xffffff, 'plane');
    plane.position.set(0, -0.5, 0);
    plane.material.map = floorTexture;
    plane.material.roughness = 0.9;
    plane.material.metalness = 0.03;
    plane.receiveShadow = true;
    scene.add(plane);

    const wallColor = 0xf4f0e6;

    const wall_1 = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 70),
        new THREE.MeshStandardMaterial({
            color: wallColor,
            metalness: 0.0,
            roughness: 0.95
        })
    );
    wall_1.rotation.set(0, 0, 0);
    wall_1.position.set(0, 35, -50);
    wall_1.receiveShadow = true;
    scene.add(wall_1);

    const wall_2 = new THREE.Mesh(
        new THREE.BoxGeometry(100, 70, 1),
        new THREE.MeshStandardMaterial({
            color: wallColor,
            metalness: 0.0,
            roughness: 0.95
        })
    );
    wall_2.rotation.set(0, 0.5 * Math.PI, 0);
    wall_2.position.set(-50, 35, 0);
    wall_2.receiveShadow = true;
    scene.add(wall_2);

    const wall_3 = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 70),
        new THREE.MeshStandardMaterial({
            color: wallColor,
            metalness: 0.0,
            roughness: 0.95
        })
    );
    wall_3.rotation.set(-Math.PI, 0, 0);
    wall_3.position.set(0, 35, 50);
    wall_3.receiveShadow = true;
    scene.add(wall_3);

    const roof = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshStandardMaterial({
            color: 0xe0e0e0,
            side: THREE.DoubleSide,
            roughness: 0.9
        })
    );
    roof.rotation.set(0.5 * Math.PI, 0, 0);
    roof.position.set(0, 70, 0);
    scene.add(roof);

    // ====================================================================
    // 천장 네모난 전등
    // ====================================================================
    const ceilingLightGeom = new THREE.BoxGeometry(30, 0.8, 18);
    const ceilingLightMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffee,
        emissiveIntensity: 2.5,
        roughness: 0.2,
        metalness: 0
    });
    const CeilingLight = new THREE.Mesh(ceilingLightGeom, ceilingLightMat);
    CeilingLight.position.set(0, 69, 0);
    CeilingLight.castShadow = false;
    scene.add(CeilingLight);

    const ceilingPoint = new THREE.PointLight(0xffffee, 0.9, 200);
    ceilingPoint.position.set(0, 68.5, 0);
    ceilingPoint.castShadow = true;
    scene.add(ceilingPoint);

    // ====================================================================
    // 2. 문과 창문 그룹
    // ====================================================================

    // Door
    const Door = createBoxMesh(15, 30, 1, 0x8b5a2b, 'Door');
    Door.rotation.set(0, Math.PI, 0);
    Door.position.set(40, 15, 49.5);
    Door.castShadow = true;
    Door.receiveShadow = true;
    scene.add(Door);

    const DoorHandle = createBoxMesh(1, 1, 1, 0xd4af37, 'DoorHandle');
    DoorHandle.position.set(5, 0, 0);
    DoorHandle.castShadow = true;
    Door.add(DoorHandle);

    // Window Groups
    function createWindowGroup(width, height, color, pos_x, pos_y, pos_z, name, rotation) {
        const group = new THREE.Group();
        group.position.set(pos_x, pos_y, pos_z);
        group.rotation.set(rotation.x, rotation.y, rotation.z);
        group.name = name;

        const windowMesh = createBoxMesh(width, height, 1, color, 'Window');
        windowMesh.material.opacity = 0.35;
        windowMesh.material.transparent = true;
        windowMesh.material.roughness = 0.1;
        windowMesh.material.metalness = 0.2;
        windowMesh.castShadow = false;
        windowMesh.receiveShadow = false;
        group.add(windowMesh);

        const curtainRod = createBoxMesh(width + 2, 1, 1, 0x333333, 'CurtainRod');
        curtainRod.position.y = (height / 2) + 1;
        curtainRod.castShadow = true;
        group.add(curtainRod);

        const curtain = createBoxMesh(width, height, 0.5, 0xfff0e6, 'Curtain');
        curtain.position.z = 0.5;
        curtain.material.roughness = 0.9;
        curtain.castShadow = true;
        curtain.receiveShadow = true;
        group.add(curtain);

        return group;
    }

    const winRotation = new THREE.Vector3(0, Math.PI, 0);
    const Window_1_Group = createWindowGroup(35, 35, 0x96c9ff, -20, 40, -49.5, 'Window_1_Group', winRotation);
    scene.add(Window_1_Group);

    const Window_2_Group = createWindowGroup(35, 35, 0x96c9ff, 20, 40, -49.5, 'Window_2_Group', winRotation);
    scene.add(Window_2_Group);

    const Window_3_Group = createWindowGroup(
        35, 35, 0x96c9ff,
        -49.5, 40, 20,
        'Window_3_Group',
        new THREE.Vector3(0, Math.PI / 2, 0)
    );
    scene.add(Window_3_Group);

    // ====================================================================
    // 3. 가구 그룹 
    // ====================================================================

    // 3-1. Bedding Group (침대)
    const beddingGroup = new THREE.Group();
    beddingGroup.position.set(-15, 0, -15);
    beddingGroup.rotation.set(0, Math.PI / 2, 0);
    beddingGroup.name = 'Bedding Group';

    const bedMesh = createBoxMesh(40, 10, 60, 0xf2d9d9, 'bed');
    bedMesh.position.y = 5;
    bedMesh.castShadow = true;
    bedMesh.receiveShadow = true;
    beddingGroup.add(bedMesh);

    const BedHead = createBoxMesh(62, 30, 3, 0x8b4513, 'BedHead');
    BedHead.position.set(0, 15, -31.5);
    BedHead.castShadow = true;
    BedHead.receiveShadow = true;
    beddingGroup.add(BedHead);

    const Pillow1 = createBoxMesh(15, 5, 20, 0xffffff, 'Pillow1');
    Pillow1.position.set(-10, 8.5, -20);
    beddingGroup.add(Pillow1);

    const Pillow2 = createBoxMesh(15, 5, 20, 0xffffff, 'Pillow2');
    Pillow2.position.set(10, 8.5, -20);
    beddingGroup.add(Pillow2);

    const BottomSheet = createBoxMesh(40, 0.5, 60, 0xfafafa, 'BottomSheet');
    BottomSheet.position.y = 10.25;
    beddingGroup.add(BottomSheet);

    const Duvet = createBoxMesh(40, 4, 45, 0x87cefa, 'Duvet');
    Duvet.position.set(0, 10.5, 7.5);
    beddingGroup.add(Duvet);

    scene.add(beddingGroup);

    // 3-2. Desk Setup Group
    const deskSetupGroup = new THREE.Group();
    deskSetupGroup.name = 'Desk Setup Group';
    deskSetupGroup.position.set(30, 0, -10);
    deskSetupGroup.rotation.y = Math.PI / 2;

    // 책상
    const deskGeom = new THREE.BoxGeometry(60, 3, 30);
    const deskBlackMat = new THREE.MeshStandardMaterial({
        color: 0x111111,
        metalness: 0.2,
        roughness: 0.4
    });
    const deskWoodMat = new THREE.MeshStandardMaterial({
        color: 0x8b6b4a,
        metalness: 0.1,
        roughness: 0.6
    });
    const deskMaterials = [
        deskWoodMat, // +X
        deskWoodMat, // -X
        deskBlackMat, // +Y 
        deskBlackMat, // -Y 
        deskWoodMat, // +Z
        deskWoodMat  // -Z
    ];
    const deskTop = new THREE.Mesh(deskGeom, deskMaterials);
    deskTop.position.y = 18;
    deskTop.castShadow = true;
    deskTop.receiveShadow = true;
    deskSetupGroup.add(deskTop);

    const legPositions = [
        [-28, 9, -13],
        [28, 9, -13],
        [-28, 9, 13],
        [28, 9, 13]
    ];

    legPositions.forEach((pos, i) => {
        const leg = createBoxMesh(3, 18, 3, 0x555555, `DeskLeg_${i + 1}`);
        leg.position.set(...pos);
        leg.castShadow = true;
        leg.receiveShadow = true;
        deskSetupGroup.add(leg);
    });

    // 모니터 2대
    const Monitor1 = createBoxMesh(12, 7.5, 1, 0x111111, 'Monitor1');
    Monitor1.position.set(-10, 24, -5);
    deskSetupGroup.add(Monitor1);

    const Monitor2 = createBoxMesh(20, 13, 1, 0x111111, 'Monitor2');
    Monitor2.position.set(7, 24, -5);
    deskSetupGroup.add(Monitor2);

    // 키보드 
    // const keyboardBase = createBoxMesh(26, 0.6, 8, 0x111111, 'KeyboardBase');
    // keyboardBase.position.set(-4.5, 19.4, 5);
    // keyboardBase.castShadow = true;
    // keyboardBase.receiveShadow = true;
    // deskSetupGroup.add(keyboardBase);

    loader.load(
        "./keyboard.glb",   
        (gltf) => {
            const keyboardModel = gltf.scene;

            // 크기, 위치, 그림자 조절
            keyboardModel.scale.set(70, 70, 70);  
            keyboardModel.position.set(-4.5, 20 , 5);
            keyboardModel.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            deskSetupGroup.add(keyboardModel);
        },
        undefined,
        (error) => {
            console.error("GLB 로딩 실패:", error);
        }
    );

    // const keycaps = createBoxMesh(25, 0.4, 7, 0x222222, 'Keycaps');
    // keycaps.position.set(0, 0.6, 0);
    // keycaps.castShadow = false;
    // keycaps.receiveShadow = true;
    // keyboardBase.add(keycaps);

    // 마우스패드 + 마우스
    const MousePad = createBoxMesh(13, 0.25, 11, 0x333333, 'MousePad');
    MousePad.position.set(15, 19.6, 5);
    MousePad.castShadow = true;
    MousePad.receiveShadow = true;
    deskSetupGroup.add(MousePad);

    const mouseBodyGeo = new THREE.SphereGeometry(1.6, 20, 20);
    const mouseBodyMat = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.4,
        metalness: 0.1
    });
    const Mouse = new THREE.Mesh(mouseBodyGeo, mouseBodyMat);
    Mouse.scale.set(1.4, 0.7, 2.0); 
    Mouse.position.set(15, 20.4, 5);
    Mouse.castShadow = true;
    Mouse.receiveShadow = true;
    deskSetupGroup.add(Mouse);

    // 컴퓨터 본체
    const Computer = createBoxMesh(6, 12, 15, 0x444444, 'Computer');
    Computer.position.set(30, 6, 0);
    deskSetupGroup.add(Computer);

    // 스피커 2개
    const Speaker1 = createBoxMesh(3, 3, 3, 0x000000, 'Speaker1');
    Speaker1.position.set(-20, 19.5, -12);
    deskSetupGroup.add(Speaker1);

    const Speaker2 = createBoxMesh(3, 3, 3, 0x000000, 'Speaker2');
    Speaker2.position.set(20, 19.5, -12);
    deskSetupGroup.add(Speaker2);

    scene.add(deskSetupGroup);


    // 3-3. Storage Group (책장 + 옷장)
    const storageGroup = new THREE.Group();
    storageGroup.name = 'Storage Group';
    // 왼쪽 벽에 붙이고, 침대 쪽을 보도록 회전
    storageGroup.position.set(0 , 0, 40 );
    storageGroup.rotation.y = Math.PI / 1;

    // --- Bookshelf  ---
    const shelfWidth = 20;
    const shelfHeight = 40;
    const shelfDepth = 14;

    const shelfGroup = new THREE.Group();
    shelfGroup.position.set(0, shelfHeight / 2, 0);

    const frameThickness = 2;

    const leftSide = createBoxMesh(frameThickness, shelfHeight, shelfDepth, 0xaa8866, 'Bookshelf_Left');
    leftSide.position.set(-shelfWidth / 2 + frameThickness / 2, 0, 0);
    shelfGroup.add(leftSide);

    const rightSide = createBoxMesh(frameThickness, shelfHeight, shelfDepth, 0xaa8866, 'Bookshelf_Right');
    rightSide.position.set(shelfWidth / 2 - frameThickness / 2, 0, 0);
    shelfGroup.add(rightSide);

    const topBoard = createBoxMesh(shelfWidth, frameThickness, shelfDepth, 0xaa8866, 'Bookshelf_Top');
    topBoard.position.set(0, shelfHeight / 2 - frameThickness / 2, 0);
    shelfGroup.add(topBoard);

    const bottomBoard = createBoxMesh(shelfWidth, frameThickness, shelfDepth, 0xaa8866, 'Bookshelf_Bottom');
    bottomBoard.position.set(0, -shelfHeight / 2 + frameThickness / 2, 0);
    shelfGroup.add(bottomBoard);

    const backPanel = createBoxMesh(shelfWidth, shelfHeight, 1, 0x8b6b4a, 'Bookshelf_Back');
    backPanel.position.set(0, 0, -shelfDepth / 2 + 0.5);
    shelfGroup.add(backPanel);

    const shelfYPositions = [-10, 0, 10];
    shelfYPositions.forEach((y, idx) => {
        const shelfBoard = createBoxMesh(
            shelfWidth - frameThickness * 2,
            1.2,
            shelfDepth - 1,
            0xb8946b,
            `Shelf_${idx + 1}`
        );
        shelfBoard.position.set(0, y, 0);
        shelfGroup.add(shelfBoard);
    });

    const bookDepth = 5;
    const bookZ = shelfDepth / 2 - bookDepth / 2 - 0.5 ; // 앞쪽
    const bookColors = [0x990000, 0x006699, 0x009900, 0xffaa00, 0x663399];

    shelfYPositions.forEach((y, idxY) => {
        for (let i = 0; i < 4; i++) {
            const bw = 1.2 + Math.random() * 0.8;
            const bh = 8 ;
            const book = createBoxMesh(bw, bh, bookDepth, bookColors[(idxY + i) % bookColors.length], `Book_${idxY}_${i}`);
            const offsetX = -shelfWidth / 2 + 4 + i * 3.5 ;
            book.position.set(offsetX, y + bh / 2 + 1, bookZ);
            shelfGroup.add(book);
        }
    });

    shelfGroup.traverse(o => {
        if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
        }
    });

    storageGroup.add(shelfGroup);


    // --- Wardrobe ---
    const wardrobeWidth = 40;
    const wardrobeHeight = 50;
    const wardrobeDepth = 18;
    const wardrobeGroup = new THREE.Group();
    wardrobeGroup.position.set(30, wardrobeHeight / 2, 0); // 책장 오른쪽

    const wThickness = 2;

    const wLeft = createBoxMesh(wThickness, wardrobeHeight, wardrobeDepth, 0x664422, 'Wardrobe_Left');
    wLeft.position.set(-wardrobeWidth / 2 + wThickness / 2, 0, 0);
    wardrobeGroup.add(wLeft);

    const wRight = createBoxMesh(wThickness, wardrobeHeight, wardrobeDepth, 0x664422, 'Wardrobe_Right');
    wRight.position.set(wardrobeWidth / 2 - wThickness / 2, 0, 0);
    wardrobeGroup.add(wRight);

    const wTop = createBoxMesh(wardrobeWidth, wThickness, wardrobeDepth, 0x664422, 'Wardrobe_Top');
    wTop.position.set(0, wardrobeHeight / 2 - wThickness / 2, 0);
    wardrobeGroup.add(wTop);

    const wBottom = createBoxMesh(wardrobeWidth, wThickness, wardrobeDepth, 0x664422, 'Wardrobe_Bottom');
    wBottom.position.set(0, -wardrobeHeight / 2 + wThickness / 2, 0);
    wardrobeGroup.add(wBottom);

    const wBack = createBoxMesh(wardrobeWidth, wardrobeHeight, 1.5, 0x4b3318, 'Wardrobe_Back');
    wBack.position.set(0, 0, -wardrobeDepth / 2 + 0.75);
    wardrobeGroup.add(wBack);

    const barGeometry = new THREE.CylinderGeometry(0.7, 0.7, wardrobeWidth - 6, 12);
    const barMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.6,
        roughness: 0.4
    });
    const hangerBar = new THREE.Mesh(barGeometry, barMaterial);
    hangerBar.rotation.z = Math.PI / 2;
    hangerBar.position.set(0, wardrobeHeight / 2 - 10, 0);
    hangerBar.castShadow = true;
    hangerBar.receiveShadow = true;
    wardrobeGroup.add(hangerBar);

    const clothesColors = [0x2b6fff, 0xff4f4f, 0xffc857, 0x3cb371];
    const clothesCount = 5;
    const clothesDepth = 6;
    const clothesZ = wardrobeDepth / 2 - clothesDepth / 2 - 1;
    for (let i = 0; i < clothesCount; i++) {
        const cw = 4;
        const ch = 18 + Math.random() * 4;
        const cloth = createBoxMesh(cw, ch, clothesDepth, clothesColors[i % clothesColors.length], `Cloth_${i}`);
        const gap = (wardrobeWidth - 10) / (clothesCount - 1);
        const cx = -(wardrobeWidth - 10) / 2 + gap * i;
        cloth.position.set(cx, hangerBar.position.y - ch / 2, clothesZ);
        cloth.castShadow = true;
        cloth.receiveShadow = true;
        wardrobeGroup.add(cloth);
    }

    wardrobeGroup.traverse(o => {
        if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
        }
    });

    storageGroup.add(wardrobeGroup);
    scene.add(storageGroup);

    
    // 4. 기타 단일 객체

    // 공기청정기
    const airPurifierGeom = new THREE.CylinderGeometry(4, 4, 20, 32);
    const airPurifierMat = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        metalness: 0.1,
        roughness: 0.4
    });
    const AirPurifier = new THREE.Mesh(airPurifierGeom, airPurifierMat);
    AirPurifier.position.set(15, 10, 45);
    AirPurifier.castShadow = true;
    AirPurifier.receiveShadow = true;
    scene.add(AirPurifier);

    // 베이스기타
    // const BassGuitar = createBoxMesh(5, 50, 1, 0x442200, 'BassGuitar');
    // BassGuitar.position.set(-40 , 25, 20);
    // BassGuitar.rotation.z = Math.PI / 10;
    // scene.add(BassGuitar);
    loader.load(
        "./bass_guitar.glb",   
        (gltf) => {
            const BassGuitar = gltf.scene;

            // 크기, 위치, 그림자 조절
            BassGuitar.scale.set(30, 30, 30);  
            BassGuitar.position.set(-40 , 25, 20);
            BassGuitar.rotation.set(0, 0, Math.PI / 4);     
            BassGuitar.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            scene.add(BassGuitar);
        },
        undefined,
        (error) => {
            console.error("GLB 로딩 실패:", error);
        }
    );

    // 침대 옆/뒤 그림
    const pictureTexture = textureLoader.load(
        'https://upload.wikimedia.org/wikipedia/commons/5/57/Malevich.black-square.jpg'
    );
    pictureTexture.encoding = THREE.sRGBEncoding;

    const pictureMaterial = new THREE.MeshStandardMaterial({
        map: pictureTexture,
        metalness: 0,
        roughness: 1,
        side: THREE.FrontSide
    });
    const pictureGeometry = new THREE.PlaneGeometry(20, 15);
    const Picture = new THREE.Mesh(pictureGeometry, pictureMaterial);
    Picture.position.set(-15, 45, -49.6); // 침대 쪽 뒷벽
    Picture.castShadow = false;
    Picture.receiveShadow = true;
    //scene.add(Picture);

    const Lamp1 = createBoxMesh(5, 5, 5, 0xfff4bf, 'Lamp1');
    Lamp1.position.set(-40, 65, 40);
    Lamp1.material.emissive = new THREE.Color(0xffe6a3);
    Lamp1.material.emissiveIntensity = 0.9;
    scene.add(Lamp1);

    const Lamp2 = createBoxMesh(5, 5, 5, 0xfff4bf, 'Lamp2');
    Lamp2.position.set(40, 65, -40);
    Lamp2.material.emissive = new THREE.Color(0xffe6a3);
    Lamp2.material.emissiveIntensity = 0.9;
    scene.add(Lamp2);

    const LightSwitch = createBoxMesh(5, 5, 0.5, 0xffffff, 'LightSwitch');
    LightSwitch.position.set(26  , 25,  50);
    scene.add(LightSwitch);

    // ====================================================================
    // Light
    // ====================================================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff2cc, 1.0);
    sunLight.position.set(120, 200, 80);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(2048, 2048);
    sunLight.shadow.camera.left = -150;
    sunLight.shadow.camera.right = 150;
    sunLight.shadow.camera.top = 150;
    sunLight.shadow.camera.bottom = -150;
    sunLight.shadow.camera.near = 10;
    sunLight.shadow.camera.far = 400;
    scene.add(sunLight);

    const pointLight = new THREE.PointLight(0xffeeaa, 0.4, 250);
    pointLight.position.set(0, 60, 0);
    pointLight.castShadow = true;
    scene.add(pointLight);

    const lamp1Light = new THREE.PointLight(0xfff0c4, 0.5, 60);
    lamp1Light.position.copy(Lamp1.position);
    lamp1Light.position.y -= 2;
    scene.add(lamp1Light);

    const lamp2Light = new THREE.PointLight(0xfff0c4, 0.5, 60);
    lamp2Light.position.copy(Lamp2.position);
    lamp2Light.position.y -= 2;
    scene.add(lamp2Light);

    // ====================================================================
    // 그림자 설정
    // ====================================================================
    [beddingGroup, deskSetupGroup, storageGroup].forEach(group => {
        group.traverse(obj => {
            if (obj.isMesh) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            }
        });
    });

    [Door, AirPurifier, /*BassGuitar,*/ Picture, Lamp1, Lamp2, LightSwitch].forEach(obj => {
        obj.castShadow = true;
        obj.receiveShadow = true;
    });

    // ====================================================================
    // Controls
    // ====================================================================
    const draggableObjects = [
        beddingGroup,
        deskSetupGroup,
        Door,
        AirPurifier,
        // BassGuitar
    ];

    const dragControls = new DragControls(
        draggableObjects,
        camera,
        renderer.domElement
    );

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.enableDamping = true;
    orbitControls.dampingFactor = 0.05;
    orbitControls.update();

    dragControls.addEventListener('dragstart', () => {
        orbitControls.enabled = false;
    });
    dragControls.addEventListener('dragend', () => {
        orbitControls.enabled = true;
    });

    function animate() {
        requestAnimationFrame(animate);
        orbitControls.update();
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
